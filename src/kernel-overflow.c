#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/uaccess.h>

MODULE_LICENSE("GPL"); 

static int major_number;
char * hackme_buf[0x1000];

static int device_open(struct inode *inode, struct file *filp)
{
        printk(KERN_ALERT "Device opened.");
    return 0;
}

static int device_release(struct inode *inode, struct file *filp)
{
        printk(KERN_ALERT "Device closed.");
    return 0;
}

static ssize_t device_read(struct file *filp, char *buf, size_t len, loff_t *offset)
{
    int tmp[32] = {0};
    tmp[0] = 0xDEADBEEF;
    tmp[31] = 0xCAFEBABE;

    memcpy(hackme_buf, tmp, len);

    if ( len > 0x1000 )
    {
        printk("Buffer overflow detected (%d < %lu)!\n", 4096LL, len);
        BUG();
    }

    if ( copy_to_user(buf, hackme_buf, len) ) return -14LL;

    return len;
}

static ssize_t device_write(struct file *filp, const char *buf, size_t len, loff_t *off)
{
    int tmp[32] = {0};
    tmp[0] = 0xDEADBEEF;
    tmp[31] = 0xCAFEBABE;

    if ( len > 0x1000 )
    {
        printk("Buffer overflow detected (%d < %lu)!\n", 4096LL, len);
        BUG();
    }
    check_object_size(hackme_buf, len, 0LL);

    if ( copy_from_user(hackme_buf, buf, len) ) return -14LL;

    memcpy(tmp, hackme_buf, len);

    // my gcc is optimizing out the memcpy
    // having tmp used after the copy ensures
    // that it stays in
    printk(KERN_ALERT "After %s",tmp);

    return len;
}

static struct file_operations fops = {
    .read = device_read,
    .write = device_write,
    .open = device_open,
    .release = device_release
};

int init_module(void)
{
    major_number = register_chrdev(0, "kernel-overflow", &fops);

    if (major_number < 0) {
            printk(KERN_ALERT "Registering char device failed with %d\n", major_number);
            return major_number;
    }

    printk(KERN_INFO "I was assigned major number %d.\n", major_number);
    printk(KERN_INFO "Create device with: 'mknod /dev/kernel-overflow c %d 0'.\n", major_number);
    return 0;
}

void cleanup_module(void)
{
    unregister_chrdev(major_number, "kernel-overflow");
}
