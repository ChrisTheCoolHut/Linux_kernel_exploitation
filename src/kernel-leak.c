#include <linux/fs.h>
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/uaccess.h>

MODULE_LICENSE("GPL");

static int major_number;
char *hackme_buf;

static int device_open(struct inode *inode, struct file *filp) {
  printk(KERN_ALERT "Device opened.");
  hackme_buf = kmalloc(0x400, 0);
  return 0;
}

static int device_release(struct inode *inode, struct file *filp) {
  printk(KERN_ALERT "Device closed.");
  kfree(hackme_buf);
  return 0;
}

static ssize_t device_read(struct file *filp, char *buf, size_t len,
                           loff_t *offset) {
  // int tmp[32] = {0};
  // tmp[0] = 0xDEADBEEF;
  // tmp[31] = 0xCAFEBABE;

  // memcpy(hackme_buf, tmp, len);

  // if (len > 0x1000) {
  //   printk("Buffer overflow detected (%d < %lu)!\n", 4096LL, len);
  //   BUG();
  // }

  if (memcpy(buf, hackme_buf, len))
    return -14LL;

  return len;
}

static ssize_t device_write(struct file *filp, const char *buf, size_t len,
                            loff_t *off) {
  int tmp[32] = {0};
  tmp[0] = 0xDEADBEEF;
  tmp[31] = 0xCAFEBABE;

  if (len > 0x1000) {
    printk("Buffer overflow detected (%d < %lu)!\n", 4096LL, len);
    BUG();
  }
  check_object_size(hackme_buf, len, 0LL);

  if (copy_from_user(hackme_buf, buf, len))
    return -14LL;

  memcpy(tmp, hackme_buf, len);

  // my gcc is optimizing out the memcpy
  // having tmp used after the copy ensures
  // that it stays in
  printk(KERN_ALERT "After %s", tmp);

  return len;
}

static struct file_operations fops = {.read = device_read,
                                      .write = device_write,
                                      .open = device_open,
                                      .release = device_release};

int init_module(void) {
  major_number = register_chrdev(0, "kernel-leak", &fops);

  if (major_number < 0) {
    printk(KERN_ALERT "Registering char device failed with %d\n", major_number);
    return major_number;
  }

  printk(KERN_INFO "I was assigned major number %d.\n", major_number);
  printk(KERN_INFO "Create device with: 'mknod /dev/kernel-leak c %d 0'.\n",
         major_number);
  return 0;
}

void cleanup_module(void) {
  unregister_chrdev(major_number, "kernel-leak");
}
